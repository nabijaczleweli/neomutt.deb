From fbf371e4d3c3b59e05364bfea409095a13b44d9c Mon Sep 17 00:00:00 2001
From: Pietro Cerutti <gahr@gahr.ch>
Date: Wed, 6 May 2020 08:34:05 +0000
Subject: [PATCH 2/3] Decode references according to RFC2047

Fixes #2315
---
 email/parse.c                        | 80 ++++++++--------------------
 email/parse.h                        |  2 +-
 test/parse/mutt_extract_message_id.c | 32 ++++++++++-
 3 files changed, 53 insertions(+), 61 deletions(-)

diff --git a/email/parse.c b/email/parse.c
index ce554f6d85..b2d459c961 100644
--- a/email/parse.c
+++ b/email/parse.c
@@ -274,13 +274,13 @@ static void parse_content_disposition(const char *s, struct Body *ct)
  */
 static void parse_references(struct ListHead *head, const char *s)
 {
-  char *m = NULL;
-  const char *sp = NULL;
+  if (!head)
+    return;
 
-  while ((m = mutt_extract_message_id(s, &sp)))
+  char *m = NULL;
+  for (size_t off = 0; (m = mutt_extract_message_id(s, &off)); s += off)
   {
     mutt_list_insert_head(head, m);
-    s = NULL;
   }
 }
 
@@ -348,75 +348,39 @@ enum ContentType mutt_check_mime_type(const char *s)
 /**
  * mutt_extract_message_id - Find a message-id
  * @param[in]  s String to parse
- * @param[out] saveptr Save result here
- * @retval ptr  First character after message-id
+ * @param[out] len Number of bytes of s parsed
+ * @retval ptr  Message id found
  * @retval NULL No more message ids
- *
- * Extract the first substring that looks like a message-id.
- * Call back with NULL for more (like strtok).
  */
-char *mutt_extract_message_id(const char *s, const char **saveptr)
+char *mutt_extract_message_id(const char *s, size_t *len)
 {
-  const char *o = NULL, *onull = NULL, *p = NULL;
-  char *ret = NULL;
-
-  if (s)
-    p = s;
-  else if (saveptr && *saveptr)
-    p = *saveptr;
-  else
+  if (!s || !*s)
     return NULL;
 
-  for (s = NULL, o = NULL, onull = NULL; (p = strpbrk(p, "<> \t;")); p++)
+  char *decoded = mutt_str_strdup(s);
+  rfc2047_decode(&decoded);
+
+  char *res = NULL;
+
+  for (const char *p = decoded, *beg = NULL; *p; p++)
   {
     if (*p == '<')
     {
-      s = p;
-      o = NULL;
-      onull = NULL;
+      beg = p;
       continue;
     }
 
-    if (!s)
-      continue;
-
-    if (*p == '>')
-    {
-      size_t olen = onull - o;
-      size_t slen = p - s + 1;
-      ret = mutt_mem_malloc(olen + slen + 1);
-      if (o)
-        memcpy(ret, o, olen);
-      memcpy(ret + olen, s, slen);
-      ret[olen + slen] = '\0';
-      if (saveptr)
-        *saveptr = p + 1; /* next call starts after '>' */
-      return ret;
-    }
-
-    /* some idiotic clients break their message-ids between lines */
-    if (s == p)
-    {
-      /* step past another whitespace */
-      s = p + 1;
-    }
-    else if (o)
+    if (beg && *p == '>')
     {
-      /* more than two lines, give up */
-      s = NULL;
-      o = NULL;
-      onull = NULL;
-    }
-    else
-    {
-      /* remember the first line, start looking for the second */
-      o = s;
-      onull = p;
-      s = p + 1;
+      if (len)
+        *len = p - decoded + 1;
+      res = mutt_str_substr_dup(beg, p + 1);
+      break;
     }
   }
 
-  return NULL;
+  FREE(&decoded);
+  return res;
 }
 
 /**
diff --git a/email/parse.h b/email/parse.h
index 7212ddfaab..a62f3babf5 100644
--- a/email/parse.h
+++ b/email/parse.h
@@ -34,7 +34,7 @@ struct Email;
 void             mutt_auto_subscribe      (const char *mailto);
 int              mutt_check_encoding      (const char *c);
 enum ContentType mutt_check_mime_type     (const char *s);
-char *           mutt_extract_message_id  (const char *s, const char **saveptr);
+char *           mutt_extract_message_id  (const char *s, size_t *len);
 bool             mutt_is_message_type     (int type, const char *subtype);
 bool             mutt_matches_ignore      (const char *s);
 void             mutt_parse_content_type  (const char *s, struct Body *ct);
diff --git a/test/parse/mutt_extract_message_id.c b/test/parse/mutt_extract_message_id.c
index 9b0994d320..aaedc42e51 100644
--- a/test/parse/mutt_extract_message_id.c
+++ b/test/parse/mutt_extract_message_id.c
@@ -23,20 +23,48 @@
 #define TEST_NO_MAIN
 #include "config.h"
 #include "acutest.h"
+#include <search.h>
 #include "mutt/lib.h"
 #include "address/lib.h"
 #include "email/lib.h"
+#include "test_common.h"
+
+int cmp(const void *a, const void *b)
+{
+  return strcmp(a, *(char **) b);
+}
 
 void test_mutt_extract_message_id(void)
 {
   // char *mutt_extract_message_id(const char *s, const char **saveptr);
 
   {
-    const char *saveptr = NULL;
-    TEST_CHECK(!mutt_extract_message_id(NULL, &saveptr));
+    size_t len;
+    TEST_CHECK(!mutt_extract_message_id(NULL, &len));
   }
 
   {
     TEST_CHECK(!mutt_extract_message_id("apple", NULL));
   }
+
+  {
+    const char *tokens[] = { "foo bar ", "<foo@bar.baz>", " moo mar", "<moo@mar.maz>" };
+    char buf[1024];
+    size_t off = 0;
+    for (size_t i = 0; i < mutt_array_size(tokens); i++)
+    {
+      off += mutt_str_strfcpy(&buf[0] + off, tokens[i], sizeof(buf) - off);
+    }
+
+    char *tmp = NULL;
+    off = 0;
+    size_t elems = mutt_array_size(tokens);
+    for (const char *it = &buf[0]; (tmp = mutt_extract_message_id(it, &off)); it += off)
+    {
+      TEST_CHECK(tmp[0] == '<');
+      char *found = lfind(tmp, &tokens[0], &elems, sizeof(char *), cmp);
+      TEST_CHECK(found != NULL);
+      FREE(&tmp);
+    }
+  }
 }
